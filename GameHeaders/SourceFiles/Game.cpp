//// Created by dominichann on 4/28/24.//#include <iostream>#include "../Game.h"#include "../TextureManager.h"#include "../Handler.h"#include "../PlayerBase.h"#include "../MissileExplo.h"#include <libAssets.h>int Game::nextID = 0;Handler* Game::handler = nullptr;AudioSystem* Game::audioSystem = nullptr;std::vector<Missile*> Game::enemyMissiles;Game::Game() {    background = nullptr;    playerBase = nullptr;    cursorG = nullptr;    missilesLoaded = 10;    stacksLeft = 3;    enemyMissiles.reserve(1);    enemyMissiles.clear();}Game::~Game() = default;SDL_Renderer* Game::renderer = nullptr;SDL_Window *Game::window = nullptr;void Game::init(const char *title, int xPos, int yPos, int width, int height, bool fullscreen) {    isRunning = false;    if((SDL_Init(SDL_INIT_EVERYTHING)) == 0) {        SDL_Log("SubSystem Initialing");        int flags = 0;        if (fullscreen)            flags = SDL_WINDOW_FULLSCREEN;        window = SDL_CreateWindow(title, xPos, yPos, width, height, flags);        if (window == nullptr) {            SDL_Log("Failed to create window: %s", SDL_GetError());            clean();        }        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);        if (renderer == nullptr) {            SDL_Log("Failed to create renderer: %s", SDL_GetError());            SDL_DestroyWindow(window);            SDL_Quit();            clean();        }else            SDL_Log("Created renderer and Window");        isRunning = true;        if (!initAssets("assets.darw"))        {            SDL_Log("Failed to load assets: %s", SDL_GetError());            SDL_DestroyWindow(window);            SDL_DestroyRenderer(renderer);            SDL_Quit();            clean();        }        loadAssetsInfo();        SDL_Surface* icon = SDL_LoadBMP(getAsset("images/icon.bmp").first.c_str()); // Load your icon image file        SDL_SetWindowIcon(window, icon);        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // Set the background color to white        SDL_Log("SubSystem Initialed");        cursorG = new Cursor(getAsset("images/cursor.png").first.c_str() , 100,100);        background = new Background(getAsset("images/back.bmp").first.c_str());        playerBase = new PlayerBase(nullptr, PLAYERBASE_X,PLAYERBASE_Y, cursorG);        Game::handler->addObject(playerBase);        Game::handler->addObject(cursorG);        audioSystem = new AudioSystem();        audioSystem->LoadMP3(getAsset("sfx/back.mp3").first.c_str());        audioSystem->PlayCurrentMP3();        for(int i = 0;i<3;i++)        {            City* temp = new City(getAsset("images/city.png").first.c_str(), (i * 180) + 30, 550);            Game::handler->addObject(temp);            cities.push_back(temp);        }        for(int i = 3;i<6;i++)        {            City* temp = new City(getAsset("images/city.png").first.c_str(), (i * 180) + 190, 550);            Game::handler->addObject(temp);            cities.push_back(temp);        }    }}void Game::handleEvents(){    SDL_Event event;    SDL_PollEvent(&event);    switch (event.type)    {        case SDL_QUIT:            isRunning = false;            break;        default:            Game::handler->handleEvents(&event);            break;    }}void Game::update() {    background->Update();  // update background    Game::handler->Update();}void Game::render() {    SDL_RenderClear(renderer);    background->Render();  // render background    Game::handler->Render();    SDL_RenderPresent(renderer);}void Game::clean() {    SDL_DestroyWindow(window);    SDL_DestroyRenderer(renderer);    releaseAssetsFile();    SDL_Quit();    SDL_Log("Game cleaned and Closed!"); }bool Game::running() const {    return isRunning;}void Game::missileShot(){    missilesLoaded--;}void Game::reload(){    missilesLoaded = 10;}short Game::missilesLeft() const {    return missilesLoaded;}void Game::addMissile(){    auto* temp = new Missile(nullptr,10,10,2,2,700,700, false);    enemyMissiles.push_back(temp);    handler->addObject(temp);}Missile* Game::checkMissileCol(MissileExplo* explo){    for(GameObject* missile : enemyMissiles)    {        if(missile->CheckCollision(explo))        {            std::cout << "HIT" << std::endl;            return dynamic_cast<Missile *>(missile);        }    }    return nullptr;}