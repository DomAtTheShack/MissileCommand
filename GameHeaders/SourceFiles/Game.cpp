//// Created by dominichann on 4/28/24.//#include <iostream>#include "../Game.h"#include "../TextureManager.h"#include "../Handler.h"#include "../PlayerBase.h"#include "../MissileExplo.h"#include <libAssets.h>#include <random>int Game::nextID = 0;Handler* Game::handler = nullptr;AudioSystem* Game::audioSystem = nullptr;bool Game::showBoaders = false;Game::Game() {    background = nullptr;    playerBase = nullptr;    cursorG = nullptr;    missilesLoaded = 10;    stacksLeft = 3;    gameOver = false;    currentDiffculty = EASY;    currentRound = 0;    roundInPlay = false;    launcher = new EnemyMissileLauncher(nullptr, 0, 0, new Timer(5), this);}Game::~Game() = default;SDL_Renderer* Game::renderer = nullptr;SDL_Window *Game::window = nullptr;void Game::init(const char *title, int xPos, int yPos, int width, int height, bool fullscreen) {    isRunning = false;    if((SDL_Init(SDL_INIT_EVERYTHING)) == 0) {        SDL_Log("SubSystem Initialing");        int flags = 0;        if (fullscreen)            flags = SDL_WINDOW_FULLSCREEN;        window = SDL_CreateWindow(title, xPos, yPos, width, height, flags);        if (window == nullptr) {            SDL_Log("Failed to create window: %s", SDL_GetError());            clean();        }        renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);        if (renderer == nullptr) {            SDL_Log("Failed to create renderer: %s", SDL_GetError());            SDL_DestroyWindow(window);            SDL_Quit();            clean();        }else            SDL_Log("Created renderer and Window");        isRunning = true;        if (!initAssets("assets.darw"))        {            SDL_Log("Failed to load assets: %s", SDL_GetError());            SDL_DestroyWindow(window);            SDL_DestroyRenderer(renderer);            SDL_Quit();            clean();        }        handler->addObject(launcher);        loadAssetsInfo();        SDL_Surface* icon = SDL_LoadBMP(getAsset("images/icon.bmp").first.c_str()); // Load your icon image file        SDL_SetWindowIcon(window, icon);        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255); // Set the background color to white        SDL_Log("SubSystem Initialed");        cursorG = new Cursor(getAsset("images/cursor.png").first.c_str() , 100,100);        background = new Background(getAsset("images/back.bmp").first.c_str());        playerBase = new PlayerBase(nullptr, PLAYERBASE_X,PLAYERBASE_Y, cursorG);        Game::handler->addObject(playerBase);        Game::handler->addObject(cursorG);        audioSystem = new AudioSystem();        audioSystem->LoadMP3(getAsset("sfx/back.mp3").first.c_str());        listAssets();        //audioSystem->PlayCurrentMP3();        for(int i = 0;i<3;i++)        {            City* temp = new City(getAsset("images/city.png").first.c_str(), (i * 180) + 30, 550, getAsset("images/destCity.png").first.c_str());            Game::handler->addObject(temp);            cities.push_back(temp);        }        for(int i = 3;i<6;i++)        {            City* temp = new City(getAsset("images/city.png").first.c_str(), (i * 180) + 190, 550, getAsset("images/destCity.png").first.c_str());            Game::handler->addObject(temp);            cities.push_back(temp);        }    }}void Game::handleEvents(){    SDL_Event event;    static bool f3Pressed = false;    while (SDL_PollEvent(&event)) {        Game::handler->handleEvents(&event);        switch (event.type)        {            case SDL_QUIT:                isRunning = false;                break;            case SDL_KEYDOWN:                if (event.key.keysym.sym == SDLK_F3) {                    f3Pressed = true;                } else if (event.key.keysym.sym == SDLK_b && f3Pressed) {                    // F3 + B pressed                    Game::showBoaders = !Game::showBoaders;  // Toggle showBorders                    std::cout << "F3 + B pressed. ShowBorders: " << (Game::showBoaders ? "On" : "Off") << std::endl;                }                break;            case SDL_KEYUP:                if (event.key.keysym.sym == SDLK_F3) {                    f3Pressed = false;                }else if(event.key.keysym.sym == SDLK_t) {                    launcher->StartMissile(EASY);                }                break;            default:                break;        }    }}void Game::update() {    background->Update();  // update background    Game::handler->Update();    Game::checkGameStatus();    Game::checkRoundStart();}void Game::render() {    SDL_RenderClear(renderer);    background->Render();  // render background    Game::handler->Render();    SDL_RenderPresent(renderer);}void Game::clean() {    SDL_DestroyWindow(window);    SDL_DestroyRenderer(renderer);    releaseAssetsFile();    SDL_Quit();    SDL_Log("Game cleaned and Closed!"); }bool Game::running() const {    return isRunning;}void Game::missileShot(){    missilesLoaded--;}void Game::reload(){    missilesLoaded = 10;}short Game::missilesLeft() const {    return missilesLoaded;}void Game::checkMissileCol(MissileExplo* explo) {    for (auto *gameObject: handler->GameObjects) {        auto *missile = dynamic_cast<Missile *>(gameObject);        if (missile) {            if( !missile->isFriendly())                {                if (missile->CheckCollision(explo))                {                    missile->explode();                }            }        }    }}void Game::checkCity(MissileExplo* explo) {    for (auto *gameObject: handler->GameObjects) {        auto *cities = dynamic_cast<City *>(gameObject);        if (cities) {            {                if (cities->CheckCollision(explo))                {                    cities->explode();                }            }        }    }}void Game::checkCity(Missile* missile) {    for (auto *gameObject: handler->GameObjects) {        auto *cities = dynamic_cast<City *>(gameObject);        if (cities) {            {                if (cities->CheckCollision(missile))                {                    cities->explode();                    handler->removeObject(missile);                }            }        }    }}void Game::checkGameStatus(){    bool gameOverCheck = true;    for (auto city: cities)    {        if(!city->isHit())            gameOverCheck = false;    }    if(gameOverCheck) {        isRunning = false;        gameOver = DEATH_BY_CITY;    }}short Game::getGameStatus() const {    return gameOver;}void Game::startRound(){    currentRound++;    switch (currentRound) {        case 1:        case 2:        case 3:        case 4:        case 5:        case 6:            currentDiffculty = EASY;            break;        case 7:        case 8:        case 9:        case 10:        case 11:        case 12:            currentDiffculty = MEDIUM;            break;        case 13:        case 14:        case 15:        case 16:        case 17:        case 18:            currentDiffculty = HARD;            break;        default:            currentDiffculty = IMMPOSSABLE;    }    launcher->StartMissile(currentDiffculty);    roundInPlay = true;}void Game::checkRoundStart() {    //Add check if score is counting and what not    if(!roundInPlay) {        startRound();    }}int Game::randomNumberGen(int a, int b){    std::random_device rd;  // Seed for the random number engine    std::mt19937 gen(rd()); // Mersenne Twister engine    // Define the range [0, 700]    std::uniform_int_distribution<> distrib(a, b);    // Generate a random number between 0 and 700    return distrib(gen);}City* Game::getCity(int num){    if(num > 5 || num < 0)        return nullptr;    return cities[num];}