#include "../Missile.h"#include "../Game.h"#include "../MissileExplo.h"#include "libAssets.h"#include <cmath>std::pair<std::string, std::string> Missile::missileSFX = {};bool Missile::madeSFX = false;Missile::Missile(const char *textureFile, float x, float y, float vX, float vY, float kpX, float kpY, bool baseMissile)        : MoviableObject(textureFile, x, y, vX, vY), killPointX(kpX), killPointY(kpY), Trail(nullptr)        {    if(!madeSFX)    {        madeSFX = true;        missileSFX = getAsset("sfx/shoot.wav");    }    else {        Game::audioSystem->LoadWAV(missileSFX.first.c_str(), false);        Game::audioSystem->PlayCurrentWAV();    }    baseMiss = baseMissile;    color = {0, 0, 0, 255};    explodeByHit = false;    prevX = x;    prevY = y;    Update();}Missile::~Missile() = default;void Missile::Update() {    trailPositions.emplace_back(xPos, yPos);    prevX = xPos;    prevY = yPos;    // Check if the missile has reached or passed the kill point    if (((velX > 0 && xPos >= killPointX) || (velX < 0 && xPos <= killPointX) ||        (velY > 0 && yPos >= killPointY) || (velY < 0 && yPos <= killPointY)) || explodeByHit) {        int x = xPos;        int y = yPos;        Game::handler->removeObject(this);        Game::handler->addObject(new MissileExplo(nullptr,x,y));        return; // Exit the update function to prevent further updates    }    MoviableObject::Update();    destRect.h = 8;    destRect.w = 10;}void Missile::Render() {    MoviableObject::Render();    SDL_SetRenderDrawColor(Game::renderer, color.r, color.g, color.b,color.a);    SDL_Rect square = {static_cast<int>(xPos), static_cast<int>(yPos), 10, 8};    SDL_RenderFillRect(Game::renderer, &square);    if(!baseMiss) {        SDL_SetRenderDrawColor(Game::renderer, 0, 0, 0, 255); // White color for the trail        // Draw the trail        for (size_t i = 1; i < trailPositions.size(); ++i) {            SDL_RenderDrawLine(Game::renderer, static_cast<int>(trailPositions[i - 1].first), static_cast<int>(trailPositions[i - 1].second),                               static_cast<int>(trailPositions[i].first), static_cast<int>(trailPositions[i].second));        }    }}std::string Missile::getObjectType() {    return "Missile";}bool Missile::isFriendly() const{    return baseMiss;}MissileTrail* Missile::getTrail(){    return Trail;}void Missile::explode() {    explodeByHit = true;}